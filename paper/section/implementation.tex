\ourtechnique attempts to invalidate a buggy execution (\aka counter
example) by inserting \sc ordered fences in the input program $P$
by the technique discussed in Section~\ref{sec:methodology}.
%
The technique relies on a {\em counter example generator} to provide
(i) a buggy execution sequence (or counter example) along with (ii)
the $\setMO$, $\setHB$ and $\setRF$ relations between the events of the
buggy execution (line 3, Algorithm~\ref{alg:fence-syn}).
%
We chose \cds \cite{cds} as the closest solution for our purpose
owing to the following reasons;

\begin{enumerate}
	\item \cds is a stateless model checker that returns execution sequences 
		with assert violations (\aka buggy executions) if any.
	
	\item Unlike competing alternatives, \cds does not halt at the detection 
		of the first buggy execution instead it continues to provide all buggy 
		executions.
	
	\item \cds also provides $\setRF$ and $\setSB$ relations between the events 
		of the buggy execution. The information returned by \cds is sufficient
		to compute the $\setHB$ and $\setMO$ relations.
	
	\item Competing alternatives that return buggy executions for an input
		program, namely \genmc \cite{genmc-PLDI19} and \tracer \cite{tracer2018}, 
		do not support our requirements.
		%
		\genmc is designed for a variant of \cc \cite{LahavVafeiadis-PLDI17} and
		does not support an option for returning all buggy executions. \tracer is
		designed for a subset of \cc that has no support for \sc, \na or \rel 
		memory orders.
\end{enumerate}

To bridge the gap between \cds's output and \ourtechnique's requirement,
we perform a pre-processing step that uses the $\setSB$ and $\setRF$ relations 
provided \cds to compute the $\setHB$ and $\setMO$ relations on the events
of the buggy executions based on the coherence rules provided by \cc model.
%
The buggy executions along with $\setSB$, $\setRF$ and computed $\setHB$ 
and $\setMO$ relations are provided as input to the core technique 
(lines 4-14, Algorithm~\ref{alg:fence-syn}) for synthesizing fences,
discussed in Section~\ref{sec:methodology}.

The core technique and the pre-processing has been implemented in 
{\tt Python}.
\ourtechnique uses {\em Johnson's} algorithm provided in {\em networkx}
library to detect cycles in the $\setSO$ relation built over the \sc
events of the intermediate execution sequence that has the complete set 
of candidate fences.

{\bf Time efficient alternative technique:} It was observed that analysis
time of the core technique and Z3 computation of min-model were impacted
by the number of buggy sequences returned by \cds.
%
As a counter measure we propose a time efficient alternative to the core 
technique that considers one buggy execution sequence at a time.
%
This technique picks any one buggy executions of input program $P$,
fixes the same by inserting \sc fences transforming $P$ to $P'$ with the
\sc fences. The technique then looks for the next buggy execution with 
$P'$ as the input program till \cds returns no buggy executions, or
finds a buggy execution that cannot be fixed with \sc fences.

The technique is not optimal in the number of fences inserted as 
\snj{provide reason}.
%
However, it was observed from the experimental results that the time
efficient technique performed significantly better in terms of the
analysis time while adding a reasonably small number of extra \sc
fences. The difference has been discussed in detail in the following 
section.
\ourtechnique attempts to invalidate a buggy execution (\aka counter
example) by inserting \sc ordered fences in the input program $P$
by the technique discussed in Section~\ref{sec:methodology}.
%
The technique relies on a {\em counter example generator} to provide
(i) buggy execution sequences (or counter examples) along with (ii)
the $\setMO$, $\setHB$ and $\setRF$ relations between the events of 
each buggy execution (line 3, Algorithm~\ref{alg:fence-syn}).
%
We recognized \cds \cite{cds} as the closest solution for our purpose
owing to the following reasons;

\begin{enumerate}
	\item \cds is a stateless model checker that returns execution sequences 
		with assert violations (\aka buggy executions) if any.
	
	\item Unlike competing alternatives, \cds does not halt at the detection 
		of the first buggy execution instead it continues to provide all buggy 
		executions.
	
	\item \cds also provides $\setRF$ and $\setSB$ relations between the events 
		of the buggy execution. The information returned by \cds is sufficient
		to compute the $\setHB$ and $\setMO$ relations.
	
	\item Competing alternatives that return buggy executions for an input
		program, namely \genmc \cite{genmc-PLDI19} and \tracer \cite{tracer2018}, 
		do not support our requirements.
		%
		\genmc is designed for a variant of \cc \cite{LahavVafeiadis-PLDI17} and
		does not support an option for returning all buggy executions. \tracer is
		designed for a subset of \cc that has no support for \sc, \na or \rel 
		memory orders. \snj{What about Herd?}
\end{enumerate}

To bridge the gap between \cds's output and \ourtechnique's requirement,
we perform a pre-processing step that uses the $\setSB$ and $\setRF$ relations 
provided by \cds to compute the $\setHB$ and $\setMO$ relations on the events
of the buggy executions, based on the coherence rules provided by \cc model.
%
The buggy executions along with $\setSB$, $\setRF$ and computed $\setHB$ 
and $\setMO$ relations are provided as input to the core technique 
(lines 4-14, Algorithm~\ref{alg:fence-syn}) for synthesizing fences as
discussed in Section~\ref{sec:methodology}.

The core technique and the pre-processing has been implemented in 
{\tt Python}.
\ourtechnique uses {\em Johnson's} algorithm provided in {\em networkx}
library to detect cycles in the $\setSO$ relation that are built over the \sc
events of the intermediate execution sequence that has the complete set 
of candidate fences (line 8, Algorithm~\ref{alg:fence-syn}).
%
Upon finding cycles, \ourtechnique uses \z theorem prover to find the 
{\em min-model} for the formula containing $\setSO$ cycles (line 13, 
Algorithm~\ref{alg:fence-syn}).

{\bf Time efficient alternative technique:} It was observed that analysis
time of the core technique and \z computation of min-model were impacted
by the number of buggy sequences returned by \cds.
%
As a counter measure we propose a time efficient alternative to the core 
technique that considers one buggy execution sequence at a time.
%
This technique picks any one buggy executions of input program $P$,
fixes the same by inserting \sc fences and  transforms $P$ to $P'$,
where $P'$ contains the newly added \sc fences along with the events already
in $P$. 
%
The technique then looks for the next buggy execution by invoking \cds 
with $P'$ as the input program. 
The process repeats till \cds returns no buggy executions, or
finds a buggy execution that cannot be fixed with \sc fences.

\begin{wrapfigure}{l}{0.45\textwidth}
	\begin{tabular}{|l|}
		\hline
		$\so{\tau_1}{}{}$ cycles in $\tau_1$\\
		\tab$\so{\tau_1}{\so{\tau_1}{\so{\tau_1}{f_1}{f_2}}{e_1}}{f_3}$\\
		\tab$\so{\tau_1}{\so{\tau_1}{\so{\tau_1}{f_3}{f_4}}{f_1}}{f_3}$\\
		$\formula{\so{\tau_1}{}{}}$ = ($f_1 \^ f_2$) $\v$ ($f_3 \^ f_4 \^ f_1$)\\
		\\
		$\so{\tau_2}{}{}$ cycles in $\tau_2$\\
		\tab$\so{\tau_2}{\so{\tau_2}{f_3}{f_4}}{f_3}$\\
		$\formula{\so{\tau_2}{}{}}$ = ($f_3 \^ f_4$)\\
		\hline
		\multicolumn{1}{r}{\scriptsize $e_i$: program events,
					$f_i$: candidate fences}
	\end{tabular}
	\caption{example showing non-optimality of the efficient version }
	\label{fig:eg}
\end{wrapfigure}

The technique is sound, \ie if the buggy behavior(s) can be stopped by 
inserting \sc fences in the program then the technique will successfully
invalidate the behavior(s);
but the technique is not optimal in the number of fences inserted.
The non-optimality of the efficient version is a result of the reduction
in information that the technique has to work with (from all buggy executions
to just one at a time). As a consequence of considering one execution per
iteration the \z formula is attenuated with terms only from one execution.
%
Consider the example in Figure~\ref{fig:eg} depicting $\setSO$ cycles in 
two buggy executions of an input program. The primary \ourtechnique 
technique would provide the formula $\formula{\so{\tau_1}{}{}}$ $\^$ 
$\formula{\so{\tau_2}{}{}}$ to \z and thus recognize $(f_3 \^ f_4 \^ f_1)$ 
as the optimal solution.
The time efficient version, however, may consider the formula 
$\formula{\so{\tau_1}{}{}}$ in the first iteration and 
$\formula{\so{\tau_2}{}{}}$ in the next iteration and return  ($f_1 \^ f_2$) 
$\^$ ($f_3 \^ f_4$) as the result which contains more fences than the 
optimal solution.

However, it was observed from the experimental results that the time
efficient technique significantly outperforms the primary technique in terms of 
the analysis time while adding a reasonably small number of extra \sc
fences. The experimental results have been discussed in detail in the 
following section.
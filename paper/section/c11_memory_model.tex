The \cc memory model \added{introduces the {\em happens-before} relation} ($\setHB$),
which is an irreflexive and acyclic relation over the events of 
a trace $\tau$ \st $\setHB \subseteq \events_\tau {\times} \events_\tau$.
A trace is {\em coherent} (or valid) under \cc if 
the $\setHB$ relation does not violate any {\em coherence rule} of \cc
\cite{batty2011mathematizing}\cite{C11}.
%
%Consider the set of memory orders $\moge \rel$ = $\{\rel, \acqrel, \sc\}$
%and $\moge \acq = \{\acq, \acqrel, \sc\}$. \svs{why not the full C11? }
%
The events of a sequence $\tau$ are related by the $\setHB$ as follows;
\begin{itemize}
	\item {\em Intra-thread-hb}: A pair of events in $P_i$ are related by
        their program order are also related by {\em sequenced-before} relation
		($\setSB$).
	
	\item {\em Inter-thread-hb}: A reads-from relation 
		$\rf{\tau}{e^w}{e^r}$ between strict ordered events $e^w, e^r$ of two 
		threads may form a synchronization between the two threads 
		\cite{batty2011mathematizing}\cite{C11}. 
		The synchronization forms an inter-thread-hb relation ($\setITHB$)
		between $e^w$ and $e^r$ and between the write events $\setSB$-ordered 
		before $e^w$ and the read events $\setSB$-ordered after $e^r$.\newline
		%
		The $\setITHB$ relation can also be formed between \cc fences 
		\cite{batty2011mathematizing}\cite{C11}.
\end{itemize}

Accordingly, two events $e_1,e_2$ in an execution sequence $\tau$ are happens-before 
related \ie
$\hb{\tau}{e_1}{e_2}$ if $\seqb{\tau}{e_1}{e_2}$ or $\ithb{\tau}{e_1}{e_2}$.
%
Additionally, in a sequence $\tau$, all write events of an object $x$ are related by a 
total order called {\em modification-order} ($\setMO$).
%
The $\setMO$ order is constructed in compliance to a set of coherence
\lmo-rules defined by \cc \cite{C11}
 based on $\setHB$ and $\setRF$ ({\em reads-from}, 
relation between a write and a read that reads the value of the write event). 
%
%The set of $\setMO$ rules are,
%\begin{itemize}[label=moWW,align=left,leftmargin=*]
%	\item [\hl{moWW}:] $\forall w_1, w_2 \in \writes_\tau$ if $\hb{\tau}{w_1}{w_2}$ then
%						$\mo{\tau}{w_1}{w_2}$\newline
%						($\setHB$ ordered writes are ordered by $\setMO$);
%	\item [\hl{moRR}:] $\forall r_1, r_2 \in \reads_\tau$ \st $\hb{\tau}{r_1}{r_2}$
%						and $\exists \rf{\tau}{w_1}{r_1}$
%						then $\rf{\tau}{w_1}{r_2}$ $\v$ $\exists \rf{\tau}{w_2}{r_2}$
%						and $\mo{\tau}{w_1}{w_2}$\newline
%						($\setHB$ between reads forms $\setMO$ between their source
%						writes (if they are different events));
%	\item [\hl{moRW}:] $\forall r_1 \in \reads_\tau$, $w_1 \in \writes_\tau$ \st
%						$\hb{\tau}{r_1}{w_1}$ then $\exists \rf{\tau}{w_2}{r_1}$ and
%						$\mo{\tau}{w_2}{w_1}$\newline
%						($\setHB$ order from a read to a write forms $\setMO$ between the
%						source of the read and the hb-after write);
%	\item [\hl{moWR}:] $\forall w_1 \in \writes_\tau$, $r_1 \in \reads_\tau$ \st
%						$\hb{\tau}{w_1}{r_1}$ then $\rf{\tau}{w_1}{r_1}$ $\v$
%						$\exists \rf{\tau}{w_2}{r_1}$ and $\mo{\tau}{w_1}{w_2}$\newline
%						($\setHB$ order from a write to a read forms $\setMO$ between
%						the write and the source of the read (if the two are
%						different events)).
%\end{itemize}
Further, we introduce an irreflexive relation \sc{\em -from-read} ($\setFR$) to relate  
\sc reads with \sc writes ordered {\em after} it.

\begin{definition}[\sc{\em -from-read} $\setFR$]\newline
	$\forall$ $r^\sc \in \ordreads{\sc}_\tau$, $w^\sc \in \ordwrites{\sc}_\tau$
	if $(r^\sc,w^\sc)$ $\in$ $\setRF^{-1};\setMO$ then $\fr{\tau}{r^\sc}{w^\sc}$;
\end{definition}

where we use $R^{-1}$ to represent the inverse of a relation $R$ and we use $R_1;R_2$
to represent the composition of two relation $R_1$ and $R_2$.
% 
A valid \cc execution must also form a total order on all events with memory
order \sc, called \sc{\em -total-order} ($\setTO$) \cite{LahavVafeiadis-PLDI17} \st
\begin{itemize}[label=to,align=left,leftmargin=*]
	\item [\hl{toHbMo}:] %$\forall e^\sc_1, e^\sc_2 \in \ordevents{\sc}_\tau$, 
			$\to{\tau}{e^\sc_1}{e^\sc_2}$ $\implies$ $\nhb{\tau}{e^\sc_2}{e^\sc_1}$ 
			$\^$ $\nmo{\tau}{e^\sc_2}{e^\sc_1}$\newline
			(\sc-total-order is coherent \wrt $\setHB$ and $\setMO$)
	\item [\hl{toFr}:] $\fr{\tau}{r^\sc}{w^\sc}$ $\implies$ $\to{\tau}{r^\sc}{w^\sc}$
			(\sc-total-order is coherent \wrt $\setFR$)
	\item [\hl{toRf}:] if %$\exists r^\sc \in \ordreads{\sc}_\tau$, $w_1 \in \writes_\tau$ \st
			$\rf{\tau}{w_1}{r^\sc}$ then $\nexists$ $w^\sc \in \ordwrites{\sc}_\tau$
			\st $\to{\tau}{\mo{\tau}{w_1}{w^\sc}}{r^\sc}$.\newline
			(an \sc read must read from its immediate \lmo before write)
\end{itemize}
%

In our technique we use the \lto-rules to build a possibly cyclic
$\setSO$ order between \sc program events and the newly inserted \sc fences.
The cyclicity in the $\setSO$ order invalidates the buggy sequence
under \cc, explained in Section~\ref{sec:so theory}.

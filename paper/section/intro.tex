% ------------ INTRO PARAS ------------------
\par
A programmer working with relaxed memory constraints would want all the advantages of the relaxed model - such as speed and concurrency. However, using relaxed memory constraints comes with its own issues. In relaxed memory models, memory operations such as \textit{reads} and \textit{writes} can be reordered in order to achieve these properties. These instruction reorderings can cause certain variables to have different values in different execution runs of the same program, hence resulting in behaviour which is unexpected or surprising. These include not behaving according to sequentially consistent standards, or outputting unexpected values of variables.

\par
In this project, we suggest an approach to prevent certain unexpected behaviour, such as unexpected outputs due to concurrent instruction re-orderings in the C11 relaxed model.

\par
To tackle this, the programmer may add \textit{"assert"} statements in the source code, which will check that certain properties remain unchanged in each run of the program, such as the value of a variable in a certain thread. Each program will have several possibilities of runs where instructions will be executed in different orders. In some of these runs, there might be cases where the assertion does not hold and it gets violated. In the case that the \textit{assert} statement gets violated, the program execution will stop. The object of this project is to insert a minimum number of \textbf{C11 fences} in the source code of the program at the right places so that these assertions are satisfied and do not get violated.

% -------------------- C11 MODEL ------------------------
\subsection{The C11 Model}
\par
Since the C/C++11 memory model is a relaxed model, load/store operations can be re-ordered before they are stored into the memory. In multi-threaded programs due to re-orderings between loads and stores, and other factors such as different methods used by different hardware for cache coherency, threads may end up seeing loads and stores by other threads in an order different than the one intended. As discussed previously, this feature can cause behaviour which is unexpected by the programmer. Two memory consistency primitives introduced into the C/C++11 model can be exploited by us in this scenario - \textit{atomic operations} and \textit{memory fences}. 

% ------------- ATOMIC OPS ----------------
\subsubsection{Atomic Operations}
Examples of atomic operations in the C/C++11 memory order are atomic loads, atomic stores, atomic read-modify-writes. These operations are carried out on atomic objects/variables.

\ishComment{insert examples of atomic ops like a.load(mo\_rel) etc}

The approach described in this project makes use of these atomic operations within the input program.

% --------------- FENCES ----------------
\subsubsection{C11 Fences}
\par
A fence in the C11 model is also an atomic instruction which can be inserted between other instructions. These fences prevent memory operations to be ordered or re-ordered past the fence and they also permit the operations to be ordered in-between threads. 

\par
A fence can have memory order SC, release, acquire. Specifically, a release fence prevents previous load/store operations from being re-ordered and moved after the fence and an acquire fence prevents load/store operations after the fence to be re-ordered and moved before the fence. On the other hand, an SC fence prevents both such behaviours. This project focuses only on SC fences and inserting them into the program in order to methodically stop instructions from re-ordering and preventing the unexpected behaviour.
\ishComment{behaviour spelling}

% ---------------- TYPES OF RELATIONS -----------
\subsection{Basic relations}
\par
In a program execution, there can be certain relations formed between instructions. Each type of relation has rules or preconditions which dictate the type of relation between any two instructions.

\par
Three basic relations which are useful in calculating many other relations are the \textit{sequenced-before}, \textit{synchronizes-with} and \textit{read-from} relations. In basic terms, any instruction in a thread is said to be sequenced before all instructions that are evaluated after it in the same thread. In order to concurrently access shared variables in a synchronized manner to avoid data races, the \textit{synchronizes-with} relation is used among instructions from different threads. Finally, a read instruction is said to be \textit{reading-from} the value of a write instruction.

These relations form the basis for all other relations which are required in the methodology of this paper.
Consider a buggy input program $P$.
%
As discussed in Section~\ref{sec:c11}, in a valid \cc execution 
sequence of $P$ (including a buggy execution or a counter example), 
the \sc ordered events must form a total order ($\setTO$).
%
Contrarily, if we synthesize \sc ordered fences in the input program 
such that the total order requirement in the buggy sequence gets violated 
then we can invalidate the sequence and stop the program behavior.
This concept forms the base of our synthesis technique.

We introduce an irreflexive and possibly cyclic relation
on \sc ordered events called \sc-order ($\setSO$).
%
To construct the $\setSO$ order, we introduce the following \lso-rules
(diagrammatically shown in Figure~\ref{fig:so rules}).
The \lso-rules are an interpretation or simply a derivative of the 
\lto-rules, \hlref{toHbMo}, \hlref{toFr} and \hlref{toRf} 
(Section~\ref{sec:c11}).
%formed by direct derivative and dual of the rules .

\begin{figure}[t]
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		\resizebox{0.19\textwidth}{!}{\input{figures/so_hbmorf.tex}} &
		\resizebox{0.19\textwidth}{!}{\input{figures/sofr.tex}} &
		\resizebox{0.19\textwidth}{!}{\input{figures/soFWfr.tex}} &
		\resizebox{0.19\textwidth}{!}{\input{figures/soRFfr.tex}} &
		\resizebox{0.19\textwidth}{!}{\input{figures/soFFsw.tex}} \\
		\hline
	\end{tabular}
	\caption{\lso-rules}
	\label{fig:so rules}
\end{figure}

\begin{itemize}[label=soFFnrf,align=left,leftmargin=*]
	\item [\hl{sohb}:] $\forall wr^{\sc}_1, wr^{\sc}_2 \in \ordevents{\sc}_\tau$ if 
			$\hb{\tau}{wr^{\sc}_1}{wr^{\sc}_2}$ then 
			$\so{\tau}{wr^{\sc}_1}{wr^{\sc}_2}$ \newline
			($\setHB$ order implies $\setSO$)
	
	\item [\hl{somo}:] $\forall w^{\sc}_1, w^{\sc}_2 \in \ordwrites{\sc}_\tau$ if 
			$\mo{\tau}{w^{\sc}_1}{w^{\sc}_2}$
			then $\so{\tau}{w^{\sc}_1}{w^{\sc}_2}$ \newline
			($\setMO$ order implies $\setSO$)
			
	\item [\hl{sorf}:] $\forall w^{\sc}_1 \in \ordwrites{sc}_\tau$, $r^{\sc}_1 \in 
			\ordreads{\sc}_\tau$ if $\rf{\tau}{w^{\sc}_1}{r^{\sc}_1}$ then 
			$\so{\tau}{w^{\sc}_1}{r^{\sc}_1}$ \newline
			($\setRF$ order implies $\setSO$)
			
	\item [\hl{sofr}:] $\forall r^\sc_1 \in \ordreads{\sc}_\tau$, $w^\sc_1 \in
			\ordwrites{\sc}_\tau$ if $\fr{\tau}{r^\sc_1}{w^sc_1}$ then 
			$\so{\tau}{r^{\sc}_1}{w^{\sc}_1}$ 
			\newline
			($\setFR$ order implies $\setSO$)
			
	\item [\hl{soFWfr}:] $\forall f^{\sc}_1 \in \ordfences{\sc}_\tau$, $w^{\sc}_1 \in 
			\ordwrites{\sc}_\tau$ if $\exists w_2 \in \writes_\tau$, $r_1 \in 
			\reads_\tau$ \st $\seqb{\tau}{f^{\sc}_1}{r_1}$, $\mo{\tau}{w_2}{w^{\sc}_1}$ 
			and $\rf{\tau}{w_2}{r_1}$ then $\so{\tau}{f^{\sc}_1}{w^{\sc}_1}$ \newline
			($\setFR$ though \sc write-fence synchronization implies $\setSO$)
			
	\item [\hl{soRFfr}:] $\forall f^\sc_1 \in \ordfences{\sc}_\tau$, $r^\sc_1 \in
			\ordreads{\sc}_\tau$ if $\exists w_1, w_2 \in \writes_\tau$ \st
			$\seqb{\tau}{w_2}{f^\sc_1}$, $\mo{\tau}{w_1}{w_2}$ and
			$\rf{\tau}{w_1}{r^\sc_1}$ then $\so{\tau}{r^\sc_1}{f^\sc_1}$\newline
			($\setFR$ though \sc read-fence synchronization implies $\setSO$)
	
%	snj: the next 3 are covered under hb implies so		
%	\item [\hl{soFFfr}:] $\forall f^\sc_1, f^\sc_2 \in \ordfences{\sc}_\tau$,
%			$w_1, w_2 \in \writes_\tau$, $r_1 \in \reads_\tau$ \st 
%			$\seqb{\tau}{f^\sc_1}{r_1}$, $\seqb{\tau}{w_2}{f^\sc_2}$, 
%			$\mo{\tau}{w_1}{w_2}$ and $\rf{\tau}{w_1}{r_1}$ then
%			$\so{\tau}{f^\sc_1}{f^\sc_2}$\newline
%			($\setFR$ though \sc fence-fence synchronization implies $\setSO$)
%			
%	\item [\hl{soWFsw}:] $\forall$ $w^\sc_1 \in \ordwrites{\sc}_\tau$ $f^\sc_1 \in
%			\ordfences{\sc}_\tau$ if $\exists r_1 \in \reads_\tau$ \st 
%			$\rf{\tau}{w^\sc_\tau}{r_1}$ and $\seqb{\tau}{r_1}{f^\sc_1}$ then 
%			$\so{\tau}{w^\sc_1}{f^\sc_1}$\newline
%			($\setSW$ between \sc write-fence implies $\setSO$)
%			
%	\item [\hl{soFRsw}:] $\forall r^\sc_1 \in \ordreads{\sc}_\tau$, $f^\sc_1 \in
%			\ordfences{\sc}_\tau$ if $\exists w_1 \in \writes_\tau$ \st
%			$\rf{\tau}{w_1}{r^\sc_1}$ and $\seqb{\tau}{f^\sc_1}{w_1}$ then
%			$\so{\tau}{f^\sc_1}{r^\sc_1}$\newline
%			($\setSW$ between \sc fence-read implies $\setSO$)
			
			
	\item [\hl{soFFsw}:]  $\forall f^{\sc}_1, f^{\sc}_2 \in \ordfences{\sc}_\tau$, 
			if $\exists w_1 \in \writes_\tau$, $r_1 \in \reads_\tau$ \st 
			$\seqb{\tau}{f^{\sc}_1}{w_1}$, $\seqb{\tau}{r_1}{f^{\sc}_2}$ 
			and $\rf{\tau}{w_1}{r_1}$ then $\so{\tau}{f^{\sc}_1}{f^{\sc}_2}$ \newline
			($\setSW$ between \sc fence-fences implies $\setSO$)
\end{itemize}

Consider a \cc execution sequence $\tau$ and a transformation
$\fixed{\tau}$ of $\tau$ \st $\events_{\fixed{\tau}}$ = $\events_\tau$
$\union$ set of synthesized fences and $\to{\tau}{}{}$ $\subseteq$
$\so{\fixed{\tau}}{}{}$.
%
Cyclic $\so{\fixed{\tau}}{}{}$ implies that there does not exist a 
total order on \sc ordered events of $\fixed{\tau}$. The sequence $\fixed{\tau}$, 
then, is not a valid \cc execution and the buggy sequence $\tau$ 
has been invalidated.

Thus, the aim of this work is to synthesis fences in the input program $P$
at appropriate locations and force a cyclic $\setSO$ order in the \sc 
ordered events of a buggy trace $\tau$ of $P$ and invalidating the trace 
for the transformed program $\fixed{P}$.
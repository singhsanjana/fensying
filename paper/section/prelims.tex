Consider a\deleted{n acyclic} multi-threaded \cc
program \added{$\parallel_{i\in \text{\tt TID}} P_i$, where $\text{\tt TID}= \{1,\ldots,n\}$ is the set of thread ids}. \deleted{The} \added{Each} thread \deleted {of the program}
\added{$P_i$ is a loop-free program, which}
performs a sequence of memory access operations on a set of shared
memory objects and \cc memory fences.  The memory access operations
can be atomic or non-atomic in nature.
%
An instance of a thread operation in an execution is called an {\em
event}.  Events of a thread $t$ are uniquely indexed with an id.
\svs {
\begin{definition}
An event $i$ of thread $t$ is represented by a tuple $\langle i, t, act, obj,$ $ ord, inst \rangle$ where:
\begin{itemize}
\item $act$ represents the event action $\in \{ \text{\tt read}, \text{\tt write}, \text{\tt rmw}, \text{\tt fence} \} $,
\item $obj$ is the set of memory objects accessed,
\item $ord$ records the memory order associated with the event, and
\item $inst$ is the corresponding program instruction.
\end{itemize}
\end{definition} }
Note that the
set of memory objects of a rmw event can be non-singleton and
\deleted{would be} empty for fence events.
%
\deleted{We use} \added{Let} $\events$ \deleted{to} denote the set of all
program events. \deleted{We further use} \added{Furthermore,}
$\writes$, $\reads$ and $\fences$
 denote the write, read and fence events of the input program.
%
An execution of $P$ is a sequence of events $\tau$ = 
$e_1.e_2...e_n$ \st $e_i \in \events$. We use $\events_\tau$
(and accordingly $\writes_\tau$, $\reads_\tau$, $\fences_\tau$)
to denote the respective sets of events in an execution sequence, 
or simply sequence, $\tau$.
\svs{why the execution of C11 program be shown as a sequence.
RC11 paper clearly avoids having this representation.}

\noindent
{\bf Memory ordering under \cc}: 
Each memory access operation and fence in a \cc program is 
associated with a memory order that defines the ordering restriction
placed on atomic and non-atomic access around atomic memory access. 
%
An event shares the same memory order as its corresponding operation
in the input program.
%
\cc provides the following set of memory 
orders, $\moset$ = $\{ \na, \rlx, \rel, \acq, \acqrel, \sc \}$, 
representing the orders relaxed (\rlx), release (\rel), acquire (\acq),
acquire-release (\acqrel) and sequentially consistent (\sc) for
atomic events. A non-atomic event has \na memory order associated with 
it.
%
We use $\ordevents{mo}_\tau$ (and accordingly $\ordwrites{mo}_\tau$, 
$\ordreads{mo}_\tau$ and $\ordfences{mo}_\tau$) to represent the $mo$
ordered events of an execution sequence $\tau$ (where, $mo \in \moset$).
\divComment{Don't call it mo. Confusing with modification order}


\noindent
{\bf \cc fences}: \cc provides atomic thread fences or simply 
fences to provide additional reordering restrictions on program 
events. Note that \cc fences are not memory barriers and do not
provide support for flushing local write values to shared memory.
%
A fence can be associated with memory orders $\acqrel$ and $\sc$
providing varying degrees of reordering restrictions.


\noindent
{\bf Buggy and invalidated executions}: The sequences of events of a 
thread of 
program $P$ may contain {\em assert checks} as a means of providing
program specification. An execution sequence that violates an 
assert check (\ie the condition in the assert check computes to
{\em false}) is called a buggy execution sequence.

The purpose of this work is to synthesize \cc fences at appropriate
program locations to invalidate a buggy sequence. Particularly, the
event interactions in the execution sequence with synthesized fences
render the resulting program behavior invalid under \cc, thus ensuring
that the previously buggy sequence would not materialize as a 
\cc program execution.

We represent the invalidated or fixed sequence corresponding to a 
buggy sequence $\tau$ by $\fx{\tau}$. 
%
As an intermediate step between $\tau$ and $\fx{\tau}$, we form an 
intermediate version of the sequence $\tau$ with candidate fences
some of which are retained as a part of $\fx{\tau}$. We represent
the intermediate version of $\tau$ as $\im{\tau}$. The details
of the intermediate step are discussed in Section~\ref{sec:methodology}.
%
We also use $\im{P}$ and $\fx{P}$ to represent the intermediate and
fixed versions of the input program $P$.

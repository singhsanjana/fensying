Consider an acyclic multi-threaded \cc program $P$. The threads
of the program perform a sequence of memory access operations 
on a set of shared memory objects and \cc memory fences.
The memory access operations can be atomic or non-atomic in
nature.
%
An instance of a thread operation in an execution sequence is
called an {\em event}. 
Events of a thread $t$ are uniquely indexed with an id. An event 
with id $i$ of thread $t$ is represented by a tuple
$\langle i, t, act, obj, ord, inst \rangle$ where $act, obj, ord,
inst$ represent the event action $\in$ $\{$reads, writes, rmws 
(read-modify-writes), fences$\}$, the memory object(s) accessed by 
the event, the memory order associated with the event and program
instruction corresponding to the event respectively.
%
We use $\events$ to denote the set of all
program events. We further use $\writes$, $\reads$ and $\fences$
to denote the write, read and fence events of the input program.
%
An execution of $P$ is a sequence of events $\tau$ = 
$e_1.e_2...e_n$ \st $e_i \in \events$. We use $\events_\tau$
(and accordingly $\writes_\tau$, $\reads_\tau$, $\fences_\tau$)
to denote the respective sets of events in an execution sequence, 
or simply sequence, $\tau$.

\noindent
{\bf Memory ordering under \cc}: 
Each memory access operation and fence in a \cc program is 
associated with a memory order that defines the ordering restriction
placed on atomic and non-atomic access around atomic memory access. 
%
An event shares the same memory order as its corresponding operation
in the input program.
%
\cc provides the following set of memory 
orders, $\moset$ = $\{ \na, \rlx, \rel, \acq, \acqrel, \sc \}$, 
representing the orders relaxed (\rlx), release (\rel), acquire (\acq),
acquire-release (\acqrel) and sequentially consistent (\sc) for
atomic events. A non-atomic event has \na memory order associated with 
it.
%
We use $\ordevents{mo}_\tau$ (and accordingly $\ordwrites{mo}_\tau$, 
$\ordreads{mo}_\tau$ and $\ordfences{mo}_\tau$) to represent the $mo$
ordered events of an execution sequence $\tau$ (where, $mo \in \moset$).

\noindent
{\bf \cc fences}: \cc provides atomic thread fences or simply \cc
fences to provide additional reordering restrictions on program 
events. Note that \cc fences are not memory barriers and do not
provide support for flushing local write values to shared memory.
%
A fence can be associated with memory orders $\acqrel$ and $\sc$
providing varying degrees of reordering restrictions.


\noindent
{\bf Buggy and invalidated executions}: The sequences of events of a 
thread of 
program $P$ may contain {\em assert checks} as a means of providing
program specification. An execution sequence that violates an 
assert check (\ie the condition in the assert check computes to
{\em false}) is called a buggy execution sequence.

The purpose of this work is to synthesize \cc fences at appropriate
program locations to invalidate a buggy sequence. Particularly, the
event interactions in the execution sequence with synthesized fences
render the resulting program behavior invalid under \cc, thus ensuring
that the previously buggy sequence would not materialize as a 
\cc program execution.

We represent the invalidated or fixed sequence corresponding to a 
buggy sequence $\tau$ by $\fx{\tau}$. 
%
As an intermediate step between $\tau$ and $\fx{\tau}$, we form an 
intermediate version of the sequence $\tau$ with candidate fences
some of which are retained as a part of $\fx{\tau}$. We represent
the intermediate version of $\tau$ as $\im{\tau}$. The details
of the intermediate step are discussed in Section~\ref{sec:methodology}.
%
We also use $\im{P}$ and $\fx{P}$ to represent the intermediate and
fixed versions of the input program $P$.
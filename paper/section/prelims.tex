Consider a multi-threaded \cc program, 
$P$ $:=$ $\parallel_{i\in \text{\tt TID}} P_i$
where $\text{\tt TID}= \{1,\ldots,n\}$, is the 
set of thread ids. 
Each thread $P_i$ is a loop-free program, which
performs a sequence of memory access operations 
on a set of shared memory objects and \cc memory 
fences.  The memory access operations can be 
atomic or non-atomic in nature.
%
An instance of a thread operation in an execution 
is called an {\em event}.  Events of a thread $t$ 
are uniquely indexed with an id.
%
{\definition {Event} \label{def:event}}\newline
An event $i$ of thread $t$ is represented by a tuple 
$\langle i, t, act, obj,$ $ ord, inst \rangle$ where:
\begin{itemize}[label=inst,align=left,leftmargin=*]
\item [$act$] represents the event action $\in 
	\{$read, write, fence$\}$,
\item [$obj$] is the memory object accessed,
\item [$ord$] records the \cc memory order associated 
	with the event, and
\item [$inst$] is the corresponding thread instruction.
\end{itemize}
%
Let $\events$ denote the set of all program events. 
Furthermore, $\writes$, $\reads$ and $\fences$ denote 
the write, read and fence events of the input program.
%
{\definition {Trace} \label{def:trace}}\newline
A trace or a maximal execution $\tau$ of the input 
program $P$ under \cc is a tuple 
$\langle \events_\tau, \setHB, \setMO, \setRF \rangle$, 
where
\begin{itemize}[label=sethb,align=left,leftmargin=*]
	\item [$\events_\tau$] $\subseteq \events$ 
		represents the set of events in the trace 
		$\tau$,
	\item [$\setHB$] ({\em Happens-before}) is a partial 
		order relation $\subseteq \events_\tau \times 
		\events_\tau$, which captures the event 
		interactions and inter-thread synchronizations, 
		discussed in Section~\ref{sec:c11},
	\item [$\setMO$] ({\em Modification-order}) is a 
		total order on the writes of an object that 
		establishes coherence of $\tau$ \wrt $\setHB$, 
		and
	\item [$\setRF$] ({\em Reads-from}) is a relation 
		from a write event to a read event signifying 
		that the read event takes the value of the write 
		event in $\tau$.
\end{itemize}

\noindent
{\bf Memory ordering under \cc}: 
The atomic memory accesses and fence operations are
associated with ordering modes that define the 
ordering restriction on atomic and non-atomic memory 
access around them.
%
$\moset$ = $\{$\na, \rlx, \rel, \acq, \acqrel, \sc$\}$, 
represents the orders relaxed (\rlx), release (\rel), 
acquire$/$consume (\acq), acquire-release (\acqrel) and 
sequentially consistent (\sc) for atomic events. 
A non-atomic event is recognized by the \na memory 
order.
%
We use $\ordevents{m}_\tau$ (and accordingly 
$\ordwrites{m}_\tau$, $\ordreads{m}_\tau$ and 
$\ordfences{m}_\tau$) to represent the $m$
ordered events of a trace $\tau$ (where, $m \in \moset$);
for example $\ordwrites{\rel}_\tau$ represents the 
write events of $\tau$ with ordering restriction \rel. 

\noindent
{\bf Buggy and fixed traces}: A program $P$ may 
contain {\em assert} statements as correctness 
specification. 
A trace of $P$ is considered {\em buggy} when an 
assert expression evaluates to {\em false} in the trace.
If traces of $P$ contain buggy traces then $P$ is 
considered buggy.
%
In this work we synthesize \cc fences at appropriate
program locations to invalidate buggy traces, thus 
ensuring that a previously buggy trace would not 
materialize as a \cc program execution.

In the processes of invalidating a buggy trace $\tau$ 
of a program $P$, $\tau$ undergoes two versions of 
transformations, an intermediate version (represented 
as $\imm{\tau}$) and a final `invalidated' version 
(represented as $\inv{\tau}$). The transformations 
have been discussed in Sections~\ref{sec:methodology} 
and \ref{sec:implementation}.
%
Note that once all the buggy traces $\tau$ have been 
transformed to the invalidated version $\inv{\tau}$ by 
adding appropriate fences, we then consider the input 
program $P$ {\em fixed} or free of bugs (represented 
as $\fx{P}$). 

\noindent
{\bf Relational Operators}: 
We use $R^{-1}$ to represent the inverse of a relation 
$R$, $R^+$ to represent the transitive closure of $R$ 
and $R_1;R_2$ to represent the composition of relations 
$R_1$ and $R_2$.
%
Let $\onsc{R}$ represent a subset of a relation $R$ on 
\sc events; \ie $(e_1,e_2) \in \onsc{R}$ $\iff$ $(e_1,e_2) 
\in R$ $\^$ $e_1,e_2 \in \ordevents{\sc}$. Note that we 
also use the infix notation $e_1Re_2$ for $(e_1,e_2) \in R$.
%
Lastly, we say a relation $R$ has cycle(s) if $\exists e_1, 
e_2 \in \events$ \st $e_1Re_2$ $\^$ $e_2Re_1$.

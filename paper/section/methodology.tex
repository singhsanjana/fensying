Given a buggy input program $P$, \ourtechnique attempts to 
stop the buggy traces or counter examples (traces with 
assert statement violations) of $P$ by inserting \cc fences.
%
To do so the technique must accomplish three objectives
(O1) determine whether the buggy trace can be stopped by 
synthesizing \cc fences,
(O2) determine the placement of optimal number of synthesized 
fences (\ie the least number of program locations where fences 
must be synthesized that is sufficient to stop the trace), 
and
(O3) determine the optimal memory order of the synthesized 
fences (\ie the weakest memory order of synthesized fences 
that is sufficient to stop the trace).
%
We present the \ourtechnique-algorithm (Algorithm
\ref{alg:main algo}) that realizes the three objectives.
The algorithm takes a \cc program as input
and determines the optimal fence placement that can stop
the buggy traces of the input program or determines that
the program cannot be made bug-free with \cc fences.

\begin{algorithm}[h]
	\caption{Fence Synthesis}
	\label{alg:main algo}
	\DontPrintSemicolon
	\SetAlgoLined
	
	\SetKwFunction{Fmain}{\ourtechnique}
	\SetKwFunction{Fceg}{generateCounterExamples}
	\SetKwFunction{FcandidateF}{candidateFences}
	\SetKwFunction{Frel}{computeRelations}
	\SetKwFunction{Fwk}{weakFensying}
	\SetKwFunction{Fst}{strongFensying}
	\SetKwFunction{Fmin}{minModel}
	
	\SetKwData{satquery}{$\Phi$}
	\SetKwData{ce}{CE}
	\SetKwData{wk}{weakCycles}
	\SetKwData{st}{strongCycles}
	
	\SetKwProg{Fn}{Function}{:}{}
	
	\Fn{\Fmain{input program $P$}}{		
		\satquery $:=$ $\top$\;
		\ce $:=$ \Fceg{$P$}\;
		\ForAll(\tcc*[f]{$\tau = \langle \events_\tau, \setHB, \setMO, \setRF \rangle$}) {$\tau \in$ \ce}{
			$\events_{\imm{\tau}}$ $:=$ $\events_\tau$ $\union$ \FcandidateF{$\tau$}\;
			$(\hb{\imm{\tau}}{}{}, \mo{\imm{\tau}}{}{}, \rf{\imm{\tau}}{}{}, \rfinv{\imm{\tau}}{}{}, \fr{\imm{\tau}}{}{})$ 
				$:=$ \Frel{$\tau,\events_{\imm{\tau}}$}\;
			\wk $:=$ \Fwk{$\imm{\tau}$}\;
			\st $:=$ \Fst{$\imm{\tau}$}\;
			\If{\wk $= \emptyset$ $\^$ \st $= \emptyset$} {
				\KwRet $\emptyset$
				\tcc*{cannot stop $\tau$}
			}			
		}
	
		\satquery $:=$ \satquery $\^$ $\formula{$\wk $\v$ \st$}$\;
		\KwRet \Fmin{\satquery}
	}
		
		
%		\State 
%		\State $ \seqb{\imm{\tau}}{}{} := $ computeSB($\setSB, \events_{\imm{\tau}}$) \State $ \so{\tau^{\mathtt{im}}}{}{} := $ computeSO($\events_{\imm{\tau}}, \setHB, \setMO, \setRF, \seqb{\imm{\tau}}{}{}$)
%		\State cycles := computeCycles($ \so{\imm{\tau}}{}{} $)
%		\If {cycles == $ \emptyset $}
%		\State \texttt{Abort} (``This trace can't be stopped using \cc fences.'')
%		\State \Return
%		\EndIf
%		\State $\phi := \phi\ \^ \formula{\so{\imm{\tau}}{}{}} $ 
%		%			\State $ \phi := \phi_\tau $
%		\EndFor
%		\State F:= MinModel($ \phi $)
%		\State \Return F



%		% no enabled events left ie maximal sequence explored
%		\lIf{\FunexploredEv{$\tau$} = $\emptyset$}{\KwRet 
%			\tcc*[f]{maximal sequence explored}}
%		
%		% if there is no sequence and no constraint sequence
%		\If(\tcc*[f]{find next event to explore}){$S = \emptysequence$}{
%			\If(\tcc*[f]{multiple leads possible}){
%				$\exists (e_r, e_w) \in$ \FunexploredRW{$\tau, F$}}{
%				\lForAll{$e_w' \in \ui{\tau}{F}{e_r}$}{
%					\Fupdate($\tau, e_w', F$)
%				}
%				\nexte := $e_r$
%			}
%			\lElse{
%				\nexte := any event $\in$ \FunexploredEv{$\tau$};
%			}
%			
%			% updateLeads wrt to selected event
%			\Fupdate($\tau$, \nexte, $F$)
%		}
%		
%		% there is a sequence to be explored
%		\lElse{
%			\nexte := $\hd{S}$
%		}
%		
%		%		\lIf(\tcc*[f]{if no branch explore \nexte})
%		\lIf
%		{$S = \emptysequence \^$ \FunexploredLd{$\tau$} = $\emptyset$}{
%			$\ld{\s{\tau}} \cunioneq (\emptysequence,\ \seq{${\nexte}$},\ F)$
%		}
%		
%		\lElseIf(\tcc*[f]{explore next event in $S$}){$S \neq \emptysequence$}{
%			$\ld{\s{\tau}} \cunioneq (\emptysequence,\ S,\ F)$
%		}
%		
%		\While(\tcc*[f]{explore all leads})
%		{$\exists l \in$ \FunexploredLd{$\tau$}}{
%			\nextseq := $l^s \cmerge l^c$\;
%			\Dprime := $\{\tau' \| \hd{${\nextseq}$}.\tau' \in Dn(\s{\tau})\}$\;
%			\Fexplore{$\tau.\hd{${\nextseq}$},\ \tl{${\nextseq}$}$, \Dprime, $l^F$}\;
%			$\dn{\s{\tau}} \unioneq$ \nextseq
%		}
%	}
\end{algorithm}
\divComment{Can we give termination guarantee?}

\noindent
{\bf Algorithm~\ref{alg:main algo} overview:} 
The algorithm assumes the knowledge of the set of counter
examples in the form of traces (\ie a set of events and 
the sets of relations on the events, as defined in Section
\ref{sec:preliminaries}).
%
Broadly the algorithm places candidate fences before and
after every program event then works towards eliminating 
fences that do not contribute to the optimal solution.
%
The elimination is a two-phase process where in the first
phase the algorithm discards candidate fences that do not 
contribute to the violation of either a coherence condition 
or the \sc total order. 
Further, in the second phase the algorithm reduces the 
remaining candidate fences to the optimal number with
the optimal memory order.

The algorithm takes a \cc program as input and relies on a 
counter example generator to return the set of counter 
examples or buggy traces of the input program (line 3).
It then transforms the buggy traces $\tau$ to an intermediate 
trace $\imm{\tau}$ by synthesizing candidate 
fences (lines 5,6).
%
The algorithm iterates over each counter example to 
collect cycles in coherence conditions or \sc total order
(lines 7,8) and aborts the process if for any buggy trace
the set of cycles is empty indicating the trace cannot be 
stopped by synthesizing \cc fences (lines 9,10).
This step constitutes the phase one where any fence not
involved in a cycle is discarded.
%
On the fences involved in the discovered cycles, we use a
SAT solver to compute the minimum number of fences
(line 11,12). 
%
The fences that contribute to the optimal (in number of
fences) set of of fences are then mapped back to their 
corresponding cycle to ascertain the memory order of 
the fence.
%
This step along with the previous step using a SAT solver
performs the phase two of elimination of candidate fences.
%
The final form of the buggy trace (with the optimal 
synthesized fences) renders the trace invalidated,
represented as $\inv{\tau}$, ensuring that the trace 
does not belong to the set of traces of the transformed
(fixed) program $\fx{P}$. 
%
We discuss the details of each step below.

\noindent
{\bf Counter examples and candidate fences:}
\ourtechnique is a fence synthesis technique to stop
buggy traces that requires a set of buggy traces to 
perform its analysis. We thus rely on an external counter
example generator that takes the input program $P$ and
returns the set of buggy traces (line 3) where each buggy 
trace is a tuple $\langle \events_\tau, \setHB, \setMO, 
\setRF \rangle$.
%
Consider the \hlref{mutex-input-program} where two 
threads are racing to mutually exclusively update the
value of $x$. The program under \cc violates the 
mutual exclusion property and a counter example generator
returns two buggy traces diagrammatically represented in
\hlref{mutex-bt1} and \hlref{mutex-bt2}.

\begin{figure}[!htb]
	\begin{center}
		\setlength{\tabcolsep}{5pt}
		\begin{tabular}{|l||l|}
			\hline
			\multicolumn{2}{|c|}{Initially: $Flag_1=0, Flag_2 = 0, x=0$} \\
			
			$ Flag_1 :=_\rlx 1 $ & $ Flag_2 :=_\rlx 1  $ \\
			\textbf{if} $ (Flag_2 =_\rlx 0) $ & \textbf{if} $ (Flag_1 =_\rlx 0) $ \\
			\quad $ x :=_\rlx 1 $ & \quad $ x :=_\rlx 2 $ \\
			\quad assert($ x =_\rlx 1 $) & \quad assert($ x =_\rlx 2 $) \\
			\hline
			
			\multicolumn{2}{c}{\hl{mutex-input-program}}
		\end{tabular} 
	\end{center}
\end{figure}

\begin{figure}[!h]
	\begin{tabular}{|c|c|c|c|}
		\hline
		\resizebox{0.24\textwidth}{!}{\input{figures/egMutex_ce1.tex}} &
		\resizebox{0.24\textwidth}{!}{\input{figures/egMutex_ce1_fences.tex}} &
		\resizebox{0.24\textwidth}{!}{\input{figures/egMutex_ce2.tex}} &
		\resizebox{0.24\textwidth}{!}{\input{figures/egMutex_ce2_fences.tex}} \\
		\hline
		
		\multicolumn{1}{c}{\hl{mutex-bt1}} &
		\multicolumn{1}{c}{$\imm{\hl{mutex-bt1}}$}  &
		\multicolumn{1}{c}{\hl{mutex-bt2}} &
		\multicolumn{1}{c}{$\imm{\hl{mutex-bt2}}$} \\
		
		\multicolumn{1}{c}{buggy trace 1} &
		\multicolumn{1}{c}{intermediate} &
		\multicolumn{1}{c}{buggy trace 2} &
		\multicolumn{1}{c}{intermediate} \\
	
		\multicolumn{1}{c}{} &
		\multicolumn{1}{c}{buggy trace 1} &
		\multicolumn{1}{c}{} &
		\multicolumn{1}{c}{buggy trace 2} \\
	\end{tabular}
\end{figure}

Algorithm~\ref{alg:main algo} iterates over each buggy trace
$\tau$ (line 4) and transforms the trace to an intermediate 
trace $\imm{\tau}$ (line 5). The algorithm further updates the 
event relations accordingly (line 6). As discussed in Section
\ref{sec:invalidating ce} a change is witnessed in the 
$\setHB$ relation. The transformed intermediate traces 
corresponding to buggy traces \hlref{mutex-bt1} and 
\hlref{mutex-bt2}, along with the updated event relations are 
represented in $\imm{\hlref{mutex-bt1}}$ and 
$\imm{\hlref{mutex-bt2}}$ respectively.

\noindent
{\bf Detecting cyclic relations indicating violation of 
	trace coherence}
In each intermediate buggy trace, the algorithm proceeds 
to perform \wkfence (line 7) and return cycles in compositions 
of event relations that define a coherence condition 
(Section~\ref{sec:c11}). For the intermediate traces 
$\imm{\hlref{mutex-bt1}}$ and $\imm{\hlref{mutex-bt2}}$
\wkfence would return an empty set.
%
The algorithm then proceeds to perform \stfence (line 8) that 
computes the $\so{\imm{\tau}}{}{}$ relation on \sc 
events and returns the cycles in $\so{\imm{\tau}}{}{}$.
The cyclic $\so{\imm{\tau}}{}{}$ relations in the intermediate
traces $\imm{\hlref{mutex-bt1}}$ and $\imm{\hlref{mutex-bt2}}$
are shown in $\imm{\hlref{mutex-bt1-so}}$ and 
$\imm{\hlref{mutex-bt2-so}}$. Note that, $\so{\imm{\tau}}{}{}$ 
would also be formed between every fence before 
$\mathbb{F}^\sc_{13}$ and every fence including and after 
$\mathbb{F}^\sc_{24}$ in $\imm{\hlref{mutex-bt1-so}}$ 
(correspondingly in $\imm{\hlref{mutex-bt1-so}}$), however, we 
have skipped the edges in the figures for better readability.

\begin{figure}[!h]
	\begin{tabular}{|c|c|}
		\hline
		\resizebox{0.24\textwidth}{!}{\input{figures/egMutex_ce1_fences_so.tex}} &
		\resizebox{0.24\textwidth}{!}{\input{figures/egMutex_ce2_fences_so.tex}} \\
		\hline
		
		\multicolumn{1}{c}{$\imm{\hl{mutex-bt1-so}}$}  &
		\multicolumn{1}{c}{$\imm{\hl{mutex-bt2-so}}$-} \\
		
		\multicolumn{1}{c}{intermediate} &
		\multicolumn{1}{c}{intermediate} \\
		
		\multicolumn{1}{c}{buggy trace 1} &
		\multicolumn{1}{c}{buggy trace 2} \\
	\end{tabular}
\end{figure}


\subsection{Reducing Fence Synthesis to SAT problem}
Recall that transitive closure of $ \so{\imm{\tau}}{}{} $ is same as 
$ \to{\imm{\tau}}{}{} $ in a valid \cc trace. Since  
$ \to{\imm{\tau}}{}{} $ is a total order, a valid \cc trace should not 
have a cycle in $ \so{\imm{\tau}}{}{} $. Conversely, if a trace has 
$ \so{\imm{\tau}}{}{} $-cycle, it cannot be a valid \cc trace. 
In order to make a trace $ \tau $ invalid under \cc, we force a \lso-cycle by inserting appropriate fences. 
Since $ \imm{\tau} $ assumes \mosc fences at all possible program locations,
any such cycle must exists in $ \so{\imm{\tau}}{}{} $. 
Hence, our problem is reduced to finding appropriate cycle in 
$\so{\imm{\tau}}{}{} $ and introducing these fences in the program to 
invalidate the trace $ \tau $.
If we introduced enough fences to cause at least \lso-cycle in 
every counter example, we stop all the buggy trace. 
It is possible that a counter example $ \tau $ does not have any 
$\so{\imm{\tau}}{}{}$-cycles. Since $ \imm{\tau} $ has \mosc fences at all 
possible program locations, we cannot add fences in such a trace to 
make it invalid \cc trace. 
Line 8 in Algorithm~\ref{alg:fence-syn} computes set $\so{\imm{\tau}}{}{}$-cycles. 
The problem of finding cycles in a graph is well-studied area. Hence, we 
choose to skip the details of this step.
If there are no $\so{\imm{\tau}}{}{}$-cycle in some $ \tau $, we conclude 
that it is not possible to stop this trace using \cc fences in lines 
9-11.


Let $ \cycles{\imm{\tau}} $ be the set of \lso-cycles in a trace $ \imm{\tau} $, 
where a cycle $ c \in \cycles{\imm{\tau}} $ is ordered sequence of 
$ \ordevents{\sc} $. We abuse the notation $\ordevents{\sc}_c$ to 
represent the set of events in a cycle $ c $. 
All the read and write events in $\ordevents{\sc}_c$ are already in program $ P $. 
Hence, to introduce a cycle $ c $ in the trace, we add the fences in $\ordevents{\sc}_c$, i.e, 
$\ordfences{\sc}_c$, in the program $ P $.
In other words, a cycle $ c $ can be introduced in a program if we insert 
$ (\bigwedge\limits_{f \in \ordfences{\sc}_c} f)$ fences in the program $ P $, 
where the truth assignment to a fence corresponds to inserting that fence 
in the program.
Recall that we need to stop at least one cycle from the set 
$ \cycles{\imm{\tau}} $ in order to make a trace $ \tau $ invalid.
Hence we need to insert $ (\bigvee\limits_{c \in \cycles{\imm{\tau}}} (\bigwedge\limits_{\fn{} \in \ordevents{\sc}_c \intersection 
\ordfences{\sc}} \fn{})) $ to stop a trace $ \tau $. 
We use $\formula{\so{\imm{\tau}}{}{}}$ to represent the boolean formula 
corresponding to the $ \so{\imm{\tau}}{}{} $-cycles.
Clearly, any satisfying assignment to $ \formula{\so{\imm{\tau}}{}{}} $ 
will give list of fences required to stop the buggy trace $ \tau $.
%
Furthermore, we construct the formula for all trace 
$ \tau \in \mathcal{CE} $ by conjuncting them in 
line 12 of Algorithm~\ref{alg:fence-syn}, i.e., 
at the end of the for loop in lines 4-12, the formula 
$ \phi \definedas (\bigwedge\limits_{\tau \in \mathcal{CE}} 
(\bigvee\limits_{c \in \cycles{\imm{\tau}}} 
(\bigwedge\limits_{\fn{} \in \ordevents{\sc}_c \intersection \ordfences{\sc}} \fn{}))) $.
Any satisfying assignment of the formula $\phi$ will list the fences that 
are enough to stop the buggy traces in $ \mathcal{CE} $.

%\begin{lemma}
%	Introducing fences in any $\so{\imm{\tau}}{}{}$-cycle will stop the counter example $ \tau $ in actual trace of the program.
%\end{lemma}

\begin{lemma}
	If there are no cycles in $\so{\imm{\tau}}{}{}$ of a buggy trace 
	$\tau$, the counter-example $ \tau $ cannot be stopped using any \cc 
	fences.
\end{lemma}

\begin{theorem}
	Any satisfying assignment to $ \formula{\so{\imm{\tau}}{}{}} $ 
	will give list of fences required to stop the buggy trace $ \tau $
\end{theorem}


\subsection{Finding Optimal Placement of the Fences}
One possible satisfying assignment to formula $ \phi $ is assigning the 
value true to all fences. Clearly such a solution is very expensive.
The number of truth assignments in the solution of formula $ \phi $ is 
equal to the number of fences inserted in the program.
%A satisfying assignment of the formula $ \phi $ with lesser number 
%of fences will give us a more optimal fence placement. 
Hence, a satisfying assignment of the formula $ \phi $ with the least 
number of fences will give us the optimal fence placement. 
Therefore, we reduce the problem of finding optimal fence placement to the 
minimal model of a SAT formula. 

The problem of minimal model computation has been studied in 
\divComment{need references}. \divComment{Need complexity argument for min model}.

In some cases, a fence at certain program location maybe more expensive 
than at other program location. For example, a fence inside a loop is may 
execute several times. Hence, such a fence may be more expensive than a 
fence placed outside the loop body.
%
\ourtechnique can handle such constraints by using weighted minimal model 
problem \divComment{need references}, where weight of each fence 
corresponds how expensive the fence is. 
The Algorithm~\ref{alg:fence-syn} can be modified to take weight 
function as input. 
%
The current implementation of \ourtechnique uses repeated calls to Z3 SAT 
solver to find the minimal model. \divComment{How are we solving it?}


\begin{theorem}
	For any input program $ P $, minimal model of $ \phi $ gives optimal
	number of fences required to stop all the buggy traces in 
	$ \mathcal{CE} $.
\end{theorem}


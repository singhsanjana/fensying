\documentclass{article}
\setlength{\parindent}{0pt}

\usepackage[dvipsnames]{xcolor}
\usepackage[colorlinks]{hyperref}
\hypersetup{
	colorlinks = true,
	citecolor = {violet},
	linkcolor = {blue},
	urlcolor  = {MidnightBlue}
}

\newcommand{\var}[1]{\color{OliveGreen} \texttt{#1}\color{black}}
\newcommand{\fun}[2]{\color{Sepia}\texttt{#1(\color{Gray}\textit{#2}\color{Sepia})}\color{black}}
\newcommand{\varinfo}[1]{\scriptsize \texttt{#1} \normalsize}
\newcommand{\class}[1]{\color{DarkOrchid}\texttt{#1}\color{black}}

\date{}
\begin{document}

\title{processing.py}
\maketitle

\par
This is the class where the root of all the processing takes place. It runs functions from classes that are imperative to the computation of the program. Classes are used in files instead of functions since creating a file with a class runs faster than creating a file with a function. The order of operations is:
\begin{enumerate}
    \item Happens-before (hb)
    \item Modification Order (mo)
    \item Add fences in the execution trace
    \item Total Order (to)
    \item Obtain cycles
    \item Translate and convert to Z3 format
\end{enumerate}
Class \class{processing } takes input parameter \var{traces}, which provides the list of all the erroneous traces as obtained from the model checking tool to the class. This class runs the above order of operations for each erroneous trace.

% ------------ INIT -------------
\section{Initialization}
\par
\var{self.z3vars } is initialized as an empty list. It will later be updated to contain the list of variable names to be used in Z3. This list will later be required while creating the Z3 file and creating Z3 constants.\\
\textit{Example:}\\
\var{self.z3vars }= \varinfo{['l18', 'l19', 'l41', 'l42', 'l23', 'l22', 'l45', 'l46']}\\

\var{self.disjunctions }will contain the list of logical operations on the Z3 variables. This list will be required to create assertions in the Z3 file.\\
\textit{Example:}\\
\var{self.disjunctions }= \varinfo{['(bvand l14 l22)', '(bvand l14 l22)']}\\

The two variables described above remain constant throughout an execution of the program. After each trace is checked, the new Z3 variables and disjunctions are added to these lists. However, there are other variables that do not remain constant and differ for each trace. For example, the fence positions, the order of instructions and the detected cycles are different for each erroneous trace. Hence, the next set of variables is re-initialized inside a loop that runs for each erroneous trace.\\

\var{fence\_thread }will contain lists of fences in a single thread. This will be used later while deciphering pairs of fences that are in sb.\\
\textit{Example:}\\
\var{fence\_thread }= \varinfo{[['F1n1', 'F1n2', 'F1n3', 'F1n4', 'F1n5', 'F1n6', 'F1n7', 'F1n8'], ['F2n1', 'F2n2', 'F2n3', 'F2n4', 'F2n5', 'F2n6'], ['F3n1', 'F3n2', 'F3n3', 'F3n4', 'F3n5']]}\\

\var{fence\_sb\_edges }will contain tuples of all the sb's that each fence has with another.\\
\textit{Example:}\\
\var{fence\_sb\_edges }= \varinfo{[('F1n1', 'F1n8'), ('F1n1', 'F1n6'), ('F1n1', 'F1n5'), ('F1n1', 'F1n7'), ('F1n1', 'F1n4'), ('F1n1', 'F1n2'), ('F1n1', 'F1n3'), ('F1n2', 'F1n7'), ('F1n2', 'F1n8'), ('F1n2', 'F1n5'), ('F1n2', 'F1n3'), ('F1n2', 'F1n6'), ('F1n2', 'F1n4'), ('F1n3', 'F1n8'), ('F1n3', 'F1n6'), ('F1n3', 'F1n4'), ('F1n3', 'F1n5')]}\\
It is a comprehensive list of each fence and its SB relations with all other fences.\\

\var{cycles }will contain the list of all cycles between fences found in this particular trace.\\

\var{loc\_info }will contain the list of possible locations, based on the cycles found. Each cycle will contain a list of fences and this variables will have information regarding the location of those fences.\\

\section{Cycles computation}
\par
% ------------- HB -------------
\subsection{Finding HB relations}
Firstly, the HB relations between the instructions are calculated. An adjacency matrix is created with the instruction numbers as the indices. This is discussed in detail in \href{hb.tex}{\textit{hb.py}}.\\
\href{hb.tex}{\fun{hb}{trace}} takes the current trace as input and calculates all the HB relations between the instructions in the trace. It provides an adjacency matrix with the relation information to \var{mat }and the size of the matrix \var{size}.

% ------------- MO -------------
\subsection{Finding MO relations}
Next, the MO relations are deduced from the HB relations. This is discussed in detail in \href{mo.tex}{\textit{mo.py}}.\\
\href{mo.tex}{\fun{mo}{trace,mat,size}} takes input parameters current trace, the HB relations adjacency matrix and the size of the matrix. This function returns a list of tuples to \var{mo\_edges}, each tuple containing a pair of instruction which have an MO relation.

\subsection{Adding pseudo fences to the program}
\var{order }runs the function \fun{fence}{trace} and obtains the list of instructions including the addition of pseudo fences. Fences are inserted before and after each instruction.\\
\textit{Example:}\\
\var{order }= \varinfo{[\\
'F2n2', \\
\{'mo': 'relaxed', 'thread': 2, 'line': '14', 'no': '7', 'loc': '0x601088', 'type': 'write'\},\\ 
'F2n3', \\
\{'loc': '0x60108c', 'mo': 'relaxed', 'thread': 2, 'line': '15', 'no': '10', 'rf': '2', 'type': 'read'\}, \\
'F2n4', \\
\{'mo': 'relaxed', 'thread': 2, 'line': '16', 'no': '13', 'loc': '0x601084', 'type': 'write'\}, \\
'F2n5', \\
\{'thread': 2, 'no': '17'\}, \\
'F2n6', \\
'F3n1', \\
\{'thread': 3, 'no': '9'\}, \\
'F3n2'\\
]}
% ------------- ALGO -------------
\subsubsection{Pseudo fences insertion algorithm}
\fun{fence}{trace}\ forms the structure described by \var{order}, defined in the class \class{processing}.\\

\var{threads }contains the total number of threads in the program, including the main thread. This is derived from the last instruction of the trace because the trace will have been sorted in ascending order according to thread numbers. The last instruction will have the last thread's last instruction. And the thread number of an instruction will be available in the second index of the list describing the instruction. Hence, \var{threads} = \varinfo{int(trace[-1][1])}\\

\var{exec }will contain the list of instructions in order including the added pseudo fences.\\

The first loop runs over the range of the number of threads in the source program, since the fences are named according to the thread they are placed in. For instance, a fence in thread 4 will be named \texttt{F4nx}, where x is the unique number given to fences in a thread. \\

\var{fence\_no }describes the fence number in a particular thread. This number is incremented each time a fence is added in a thread.\\

The second loop runs over the range of the instructions in the traces. The instructions are extracted and fences are placed around them. Firstly, a fence is placed before an instruction.\\
\var{exec }is the list that contains all the instructions with the fences included, so the fence is added to it.\\
\var{fences\_in\_thread }would contain the list of all fences in a particular thread.\\
\var{self.fences }contains the list of all pseudo fences added to the source program.\\

After a fence is added, the instruction that should come after it is added. Since all the metadata of the instruction is not required, only certain important properties are extracted and a dictionary for each instruction is created. A temporary dictionary is stored in \var{event}, which includes \texttt{event number, thread number, instruction type, rf value, memory order, memory location, line number}. This dictionary is created for each instruction and appended to \var{exec}.\\

Once a single thread has been covered and fences have been added, then it moves on to the next thread. Before moving on to the next thread, another fence is added to the thread after the last instruction in the thread. And after each thread is over, \var{self.fence\_thread }is appended with the list of all fences in that particular thread. This list contains lists of fences separated by which thread they are in.\\

Therefore, \var{exec }includes the order of instructions after pseudo fence addition, \var{self.fences }includes the list of all the pseudo fences and \var{self.fence\_thread }includes a list of lists of fences in a thread.

% ------------- FENCE SB -------------
\subsubsection{Finding SB pairs between fences}
\fun{sb}{trace,threads}\ creates a list of tuples with pairs of SB's between fences. It takes the list \var{self.fence\_thread}, which contains lists of fences in a thread and creates tuples of fence SB pairs. A fence at the top of the thread will have SB relations with all the instructions and fences below it. Hence if there are 5 fences in the thread, the fence on top will have SB relations with 4 of the fences, the second fence with 3 fences and so on. This function will create this comprehensive list of tuples containing all such relations and put it in \var{fence\_sb\_edges}.\\

\var{fence\_sb\_edges }is also sorted using function \fun{sort()} according to the first value of each tuple. Function \fun{sort() } is used instead of \fun{sorted() } since it saves space - it replaces the values in the old list instead of creating a new list.\\
The sorting is done using the \fun{lambda} function for parameter \texttt{key}. This technique is faster because the key function is called exactly once for each input record.

% ------------- TO -------------
\subsection{Finding TO relations}
The TO relations between the fences are deduced, using the above calculated relations (MO, SB, SW, RF).\\
\href{to.tex}{\fun{to}{order,mo\_edges,self.fence\_sb\_edges}} takes parameters - order of instructions, MO relations, and SB relations between the fences and returns a list of tuples to \var{to\_edges}. These tuples are pairs of fences which have TO relations between them.\\
\textit{Example:}\\
\var{to\_edges }= \varinfo{[
('F1n1', 'F2n4'), ('F1n1', 'F3n3'), ('F1n1', 'F2n5'), ('F3n3', 'F2n5'), 
('F3n3', 'F2n6'), ('F3n4', 'F1n12')]}

\subsection{Finding cycles in the trace}
Finally, cycles in the graph formed by the above TO relations are detected for the current trace being explored.\\
\href{cycle.tex}{\fun{Cycles}{self.fences,self.fence\_sb\_edges,to\_edges}} takes inputs total fences, SB relations between fences and TO relations between fences and returns the detected cycles from the graph into \var{cycles}.\\
\textit{Example:}\\
\var{cycles }= \varinfo{[ ['F2n3', 'F2n4', 'F2n5', 'F3n4'],
['F2n3', 'F2n4', 'F3n4'],
['F2n3', 'F2n5', 'F3n4'],
['F2n3', 'F3n4'],
['F2n4', 'F2n5', 'F3n4'],
['F2n4', 'F3n4'],
['F2n5', 'F3n4']
]}

\section{Translation into Z3 format}
\var{unique\_fences }contains the list of all the fences that are involved in cycles. This is derived from \var{cycles}, which contains lists of fences that are in cycles.\\
\textit{Example:}\\
\var{unique\_fences }= \varinfo{['F2n3', 'F2n4', 'F2n5', 'F3n4']}\\

The tool first checks if there are any cycles forming at all. In case there are no cycles in a particular trace, the program exits and gives the message \small \texttt{"No TO cycles can be formed for trace \textit{trace\_no}, hence this behaviour cannot be stopped using SC fences"}\\

If there are cycles between fences in the trace, then it proceeds on to translate the information into Z3 format for the next step. For each fence, a Z3 variable is created. Hence, a loop runs for the number of fences and creates a variable out of each, with some other metadata as well.\\

The variable is named according to the line number in the source program below which the fence is supposed to be added. The format of the Z3 variable is \begin{center}
    \texttt{'l' + line number}
\end{center}
The line number is derived by obtaining the line number of the instruction above the fence.\\

Out of each fence, a dictionary is created and added to list \var{loc\_info}. This dictionary would contain the name of the fence, the name of the Z3 variable and the line number in the source program below which the fence is to be inserted. Adding these values will be useful later on.\\

\href{instructionsz3.tex}{\fun{translate\_z3}{cycles,self.loc\_info}} takes the cycles found in the trace and the information about each of them and returns a list of Z3 constants to \var{consts }and a list of Z3 disjunctions created from the cycles to \var{translation }for later computation. These are then appended to the lists \var{self.z3vars }and \var{self.disjunctions}, which contain the constants and disjunctions of all the traces.\\

Finally, the Z3 variables and disjunctions are added into a Z3 file format.\\
\href{stitchz3.tex}{\fun{convert\_z3}{self.z3vars,self.disjunctions}} takes these parameters and produces a Z3 file which will be executed later on.

\end{document}